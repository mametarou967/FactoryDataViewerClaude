# Decisions

## 通信方式: ポーリング型を採用
- **決定**: GWがマスター、エッジがスレーブのポーリング型
- **理由**: 22ユニットが非同期送信すると電波衝突が発生する。機械が増えるほど衝突頻度が上がりスケールしない。ポーリング型は順番に問い合わせるため衝突を原理的に回避できる。

## ユニット種別把握: GW設定ファイル方式
- **決定**: GWの設定ファイルにユニット種別を記載（初回ハンドシェイクは不採用）
- **理由**: シンプルで確実。22台規模ならば手動設定のコストは許容範囲。

## データ保存: 機械ごとにサブディレクトリ
- **決定**: `data/sensor/<機械名>/YYYY-MM-DD.csv`
- **理由**: 機械ごとにファイルを分けることで、Web表示・検索・バックアップが容易になる。

## 1機械に2ユニットを紐付け
- **決定**: GW設定ファイルで `機械名 → {patlite_addr, current_addr}` をマッピング
- **理由**: パトライトと電源の取得位置が物理的に離れているため別ユニットが必要。ただしデータはGWで統合して1つの機械として扱う。同一ユニットが両機能を兼務する場合は同じアドレスを設定する。

## I2Cバスを2系統に分離（Wire / Wire1）
- **決定**: TCA9548A+TSL2561はWire（GPIO20/21）、SSD1306はWire1（GPIO26/27）
- **理由**: 回路設計時点で意図的に分離済み。バス競合なし。

## 状態判定ロジックの配置: GW側
- **決定**: エッジは生データ（lux値・電流値）を送るだけ。状態判定（加工中/停止等）はGWで行う。
- **理由**: 閾値は機械ごとに異なるため、GW側の設定で一元管理した方が変更が容易。
- **閾値構造**: 機械ごとに `patlite_thresholds: {red, yellow, green}`（lux）と `current_threshold`（A）の1値を持つ。電流閾値は「加工中/加工なし」の2値判定のみ。
- **状態の種類**: 停止(gray) / 自動加工中(green) / 手動加工中(blue) / 加工完了(yellow) / アラーム(red)
- **優先ルール**: 緑点灯=自動加工中が最優先。緑消灯＋電流≥閾値=手動加工中。緑消灯＋電流<閾値でパトライト組み合わせにより停止/完了/アラームを判定。

## センサーサンプリング: デュアルコア常時サンプリング
- **決定**: Core1でセンサーを常時サンプリングし、Core0はコマンド受信時に即座に応答
- **理由**: パトライトが回転しており、瞬時値だけでは光源が反対側を向いているタイミングで消灯誤判定が発生する。直近1.5秒間のmax値を保持することで確実に点灯を検出できる。Core1を専用に割り当てることでタイムアウト内（500ms）に即応答可能。
- **電流も同様**: 交流のRMS計算にも高速サンプリングが必要なためCore1で担当。
- **コア間共有**: mutex_tで`patlite_max[3]`・`current_rms`・`sensor_error`を保護。

## パケットフォーマット: バイナリ + CRLFターミネータ
- **決定**: コマンドはASCII1文字、データはバイナリ、終端は`\r\n`
- **理由**: コマンドをASCII文字にすることでデバッグ時に人間が読める。データはバイナリで最小バイト数に抑えLoRa転送効率を優先。CRLFはプロトタイプ実績があり`read_until()`で確実に受信できる。
- **コマンドコード**: P=Patlite, C=Current, K=Knock(ping), H=Hardware, V=Version, U=Update(OTA予約), E=Error

## エッジのLED用途
- **決定**: D1=ハートビート(1秒点滅), D2=LoRa通信状態, D3=センサー異常, D4=モード表示
- **理由**: ユニットは高所（3〜4m）に設置されるため、パネル引き出しLEDで遠目から一目で状態を把握できる構成にした。ハートビートでフリーズを検知、D2でLoRa断線を検知できる。
- **D1の実装**: Core0のみでなくCore1の生存も確認する。Core1がloop1()内でcore1_heartbeatカウンタをインクリメントし、Core0が1秒ごとにカウンタの変化を確認してD1を制御。Core1フリーズ時はカウンタが変わらずD1が止まる。

## 多工場対応: チャンネルで工場を分離
- **決定**: 工場ごとに専用のGW（RPi5 + USB E220）を用意し、LoRaチャンネルで工場間を分離する。各工場のアドレス空間は独立（0x0000〜0x0016を工場ごとに使い回し可）。
- **理由**: 各工場が独立したGWを持つため、アドレスをグローバル管理する必要がない。チャンネル分離により同一建物内でも電波干渉なし。新工場追加時はチャンネルを1つ増やすだけでスケールする。
- **チャンネル割り当て**: config.yamlの `gw_channel` で工場ごとに設定（例: 工場1=18, 工場2=19, ...）。

## GWアプリケーション構成: Flask統合（app.py + lora_logger.py を統合）
- **決定**: LoRaポーリング（旧lora_logger.py）とWebアプリ（旧app.py）を1つのapp.pyに統合する。server_file_copy.pyはcronで独立実行のまま。
- **理由**: E220のシリアルポートは同時に1プロセスしか保持できない。メンテナンス操作（K/H/V/OTA）もWebUIからトリガーするため、分離構成ではプロセス間通信が必須になりかえって複雑になる。統合＋バックグラウンドスレッドの方がシンプルで実用的。
- **信頼性**: systemdの `Restart=always` でプロセス障害時に自動再起動することで、分離構成と同等の可用性を確保する。
- **K/H/V/Uコマンドの位置づけ**: 定期ポーリング（1分周期）には含めず、Webメンテナンス画面からのオンデマンド実行のみ。

## E220設定の保存先: E220本体のE2PROM
- **決定**: LoRaアドレス・チャンネル等のE220設定はPicoのFlashではなくE220本体のE2PROMに書き込む
- **理由**: E220はATコマンド（設定モード）でE2PROMへの読み書きが可能。電源を切っても設定が保持され、Pico側でのFlash管理が不要になる。

## E220コマンド受信: AUX割り込み方式
- **決定**: AUX(GPIO6)のRISINGエッジ割り込みでコマンド到着を検知し、`Serial2.available()`で受信/送信後を区別
- **理由**: ブロッキングループを排除し、Core0のloop()でLED・ボタン・表示を並行処理できる。送信後もAUXがRISINGするが、その際はRXバッファが空なのでステート変数なしに区別可能。
- **起動時注意**: `attachInterrupt()` の前にAUX=HIGHを確認してE220の初期化完了を待つこと。
- **効果**: Step1でコマンド受信基盤が完成し、Step2以降はコマンド種別を追加するだけでよい。

## 実装方針: 段階的（Step1→5）
- **決定**: 一気に実装せず、Step単位で動作確認しながら進める
- **理由**: 機能が多岐にわたるため、バグ切り分けと動作確認を確実に行うことを優先。GW実機でテストできる環境が用意可能なため、Step1からリアルな通信テストが可能。

## OTAの実装順序: 最後
- **決定**: 通常機能・設定UI・ローカルテストがすべて完成してからOTAを追加
- **理由**: OTA失敗時にユニットが文鎮化するリスクがあるため、基本機能が安定してからの方が安全。
- **補足**: 設置場所が高所（3〜4m）のため物理アクセスが困難。LoRa経由OTA（9.6kbps設定で1台あたり5〜10分程度）で対応予定。
