# Decisions

## 通信方式: ポーリング型を採用
- **決定**: GWがマスター、エッジがスレーブのポーリング型
- **理由**: 22ユニットが非同期送信すると電波衝突が発生する。機械が増えるほど衝突頻度が上がりスケールしない。ポーリング型は順番に問い合わせるため衝突を原理的に回避できる。

## ユニット種別把握: GW設定ファイル方式
- **決定**: GWの設定ファイルにユニット種別を記載（初回ハンドシェイクは不採用）
- **理由**: シンプルで確実。22台規模ならば手動設定のコストは許容範囲。

## データ保存: 機械ごとにサブディレクトリ
- **決定**: `data/sensor/<機械名>/YYYY-MM-DD.csv`
- **理由**: 機械ごとにファイルを分けることで、Web表示・検索・バックアップが容易になる。

## 1機械に2ユニットを紐付け
- **決定**: GW設定ファイルで `機械名 → {patlite_addr, current_addr}` をマッピング
- **理由**: パトライトと電源の取得位置が物理的に離れているため別ユニットが必要。ただしデータはGWで統合して1つの機械として扱う。同一ユニットが両機能を兼務する場合は同じアドレスを設定する。

## I2Cバスを2系統に分離（Wire / Wire1）
- **決定**: TCA9548A+TSL2561はWire（GPIO20/21）、SSD1306はWire1（GPIO26/27）
- **理由**: 回路設計時点で意図的に分離済み。バス競合なし。

## 状態判定ロジックの配置: GW側
- **決定**: エッジは生データ（lux値・電流値）を送るだけ。状態判定（加工中/停止等）はGWで行う。
- **理由**: 閾値は機械ごとに異なるため、GW側の設定で一元管理した方が変更が容易。

## センサーサンプリング: デュアルコア常時サンプリング
- **決定**: Core1でセンサーを常時サンプリングし、Core0はコマンド受信時に即座に応答
- **理由**: パトライトが回転しており、瞬時値だけでは光源が反対側を向いているタイミングで消灯誤判定が発生する。直近1.5秒間のmax値を保持することで確実に点灯を検出できる。Core1を専用に割り当てることでタイムアウト内（500ms）に即応答可能。
- **電流も同様**: 交流のRMS計算にも高速サンプリングが必要なためCore1で担当。
- **コア間共有**: mutex_tで`patlite_max[3]`・`current_rms`・`sensor_error`を保護。

## パケットフォーマット: バイナリ + CRLFターミネータ
- **決定**: コマンドはASCII1文字、データはバイナリ、終端は`\r\n`
- **理由**: コマンドをASCII文字にすることでデバッグ時に人間が読める。データはバイナリで最小バイト数に抑えLoRa転送効率を優先。CRLFはプロトタイプ実績があり`read_until()`で確実に受信できる。
- **コマンドコード**: P=Patlite, C=Current, K=Knock(ping), H=Hardware, V=Version, U=Update(OTA予約), E=Error

## エッジのLED用途
- **決定**: D1=ハートビート(1秒点滅), D2=LoRa通信状態, D3=センサー異常, D4=モード表示
- **理由**: ユニットは高所（3〜4m）に設置されるため、パネル引き出しLEDで遠目から一目で状態を把握できる構成にした。ハートビートでフリーズを検知、D2でLoRa断線を検知できる。

## E220設定の保存先: E220本体のE2PROM
- **決定**: LoRaアドレス・チャンネル等のE220設定はPicoのFlashではなくE220本体のE2PROMに書き込む
- **理由**: E220はATコマンド（設定モード）でE2PROMへの読み書きが可能。電源を切っても設定が保持され、Pico側でのFlash管理が不要になる。

## E220コマンド受信: AUX割り込み方式
- **決定**: AUX(GPIO6)のRISINGエッジ割り込みでコマンド到着を検知し、`Serial2.available()`で受信/送信後を区別
- **理由**: ブロッキングループを排除し、Core0のloop()でLED・ボタン・表示を並行処理できる。送信後もAUXがRISINGするが、その際はRXバッファが空なのでステート変数なしに区別可能。
- **起動時注意**: `attachInterrupt()` の前にAUX=HIGHを確認してE220の初期化完了を待つこと。
- **効果**: Step1でコマンド受信基盤が完成し、Step2以降はコマンド種別を追加するだけでよい。

## 実装方針: 段階的（Step1→5）
- **決定**: 一気に実装せず、Step単位で動作確認しながら進める
- **理由**: 機能が多岐にわたるため、バグ切り分けと動作確認を確実に行うことを優先。GW実機でテストできる環境が用意可能なため、Step1からリアルな通信テストが可能。

## OTAの実装順序: 最後
- **決定**: 通常機能・設定UI・ローカルテストがすべて完成してからOTAを追加
- **理由**: OTA失敗時にユニットが文鎮化するリスクがあるため、基本機能が安定してからの方が安全。
- **補足**: 設置場所が高所（3〜4m）のため物理アクセスが困難。LoRa経由OTA（9.6kbps設定で1台あたり5〜10分程度）で対応予定。
